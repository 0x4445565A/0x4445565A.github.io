---
permalink: /projects/{{year}}/{{slug}}
title: Rust BF Interpreter
published_date: 2023-06-19 22:28:45.438136836 +0000
layout: post.liquid
is_draft: false
data:
  hide: false
  tags: Rust, Esoteric Programming 
  summary: My very own BF interpreter because why not.
  img: assets/posts/img/yabfi-example.png
---
# Yet Another Brain F*ck Interpreter
-- See project <a href="https://github.com/0x4445565A/yabfi" target="_blank" rel="noopener noreferrer nofollow">here</a>

<img src="/assets/posts/yabfi-hello-world.png">

## What is BF
Brain F*ck, also known as BF and brain-lang, is an esoteric programming language.  If you are unfamiliar <a href="https://www.youtube.com/watch?v=hdHjjBS4cs8" target="_blank" rel="noopener noreferrer nofollow">this video</a> is a great primer. Its syntax is so simple, with only 8 symbols `+-[].,><`, but in its simplicity it becomes almost unusable.  At its core BF has a static sized buffer.  This buffer stores a byte, initialized with 0.  To interact with the buffer you use `+-` to increment and decrement the buffer at the current pointer. `><` shifts the pointer to the right and left. `.` prints the current value at the pointer as an ascii character. `,` requests a number from STDIN and places it in the pointer position.


## What is YABFI
Yet Another Brain F*ck Interpreter is just another interpreter for BF, written in Rust.  While the world didn't need ANOTHER Rust powered BFI, I really wanted to write one.  I figured since I'm still learning Rust it would make for another awesome project.

## Constraints
As will all of my projects I started with constraints and project steps.  The constraints were as follows..
  - Accepts common BF code and print the expected result
  - Accepts BF code from STDIN
  - Accepts BF code in an python CLI like environment
  - Has extra features to make the CLI interpreter environment easier to use

## Challenges
Ultimately this project went by super smoothly.  Brain-lang is very well documented, however I avoided looking at anyone's code so I could keep the challenge.

The first issue I ran into was supporting wrap around addition and subtraction.  In BF if I execute `0-1` it should return 255, which does not play well with Rust's `u8` type, it immediately throws an overflow error.  So I considered switching to `i16` to abuse the signed bit, but there were many issues with this and the Rust compile caught me out.  After digging through the Rust docs I found `wrapping_add()` (<a href="https://doc.rust-lang.org/std/primitive.u8.html#method.wrapping_add" target="_blank" rel="noopener noreferrer nofollow">Read more here</a>).  This allows me to do that math but ignore the carrying digit.  Additionally the `wrapping_sub()` does the same for me going in the opposite direction.

The final challenge was figuring out how to handle the loops.  BF Loops are pretty simple.  When you encounter a `[` if the current pointer value is `0` you skip to the matching `]`.  When you encounter a `]` you jump back to the matching `[`.  The way I handled this was actually pretty simple.

I do this with a single `Vec<usize>`.  All I do it I `push()` the program cursor position to the stack when I see a `[`.  When I see a `]` I `pop()` the loop stack and store that.  If the `buf[pointer]` value is `0` I move forward exiting the loop otherwise I skip the cursor back the popped value.  The stack of course is so I can have multiple nested loops and keep track of them all.

```
match program[cursor] as char {
  // -- snip --
  '[' => stack.push(cursor),
  ']' => {
      let start = stack.pop().unwrap();
      // Set the cursor back to the start of the loop
      if arr[p] != 0 {
          cursor = start;
          continue;
      }
  }
}
```

## Conclusion
YABFI is a silly little program that was written in about 3 hours.  I had a lot of fun writing it and was given an opportunity to dive into Rust's primitive type methods.  I think the idea of creating a Brain-lang CLI interpreter with a consistent buffer is fairly novel.  10/10 would write again.

<img src="/assets/posts/yabfi.png">