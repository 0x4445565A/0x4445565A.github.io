<b>Update:</b> I rewrote parts of portanoia to be concurrent and I think now it could possibly handle as many connections that Go can throw at it.  There are also several new performance changes like dropping inbound tcp connections automatically.

A Honeyport is a concept I came up with a few years ago(Probably already exists but I didn't really look into it).  At its core, it's just a port that your box listens on and if it has any activity it performs an action against the intruding IP address.  The action in most cases is just blocking the IP with something like iptables.  A few ways to leverage this program in real life is to block attackers, announce attacker information via espeak, or even launch hailmary hack backs(Let me know if anyone has a success story with this!).

Initially I created a Honeyport program in Python but it wasn't anything fun and it was very slow.  This is where <a href="https://github.com/0x4445565A/portanoia" target="_blank">Portanoia</a> comes in.  I wrote it as a chance to work with raw packets in Go.  Put simply it takes two input flags, a port and a command.  The command can take tokens in it that will be replaced with data like the destination port, source ip address, etc.  If the port has data sent to it the command will be triggered.

To break <a href="https://github.com/0x4445565A/portanoia" target="_blank">Portanoia</a> down first it processes the CLI flags using the <a href="https://golang.org/pkg/flag/" target="_blank" nofollow>flag package</a>.  This is where the command and port number are discovered.  Using the port number we use the <a href="https://golang.org/pkg/net/" target="_blank" nofollow>net package</a> to listen for TCP packets.

This is where things get fun!  We start capturing the traffic using raw sockets(To read up a bit on raw sockets, <a href="http://man7.org/linux/man-pages/man7/ip.7.html" target="_blank" nofollow>this is a good resource</a>).  We filter the socket for TCP only and read 1024 bytes at a time.  Before going over the dissecting of the IPv4 packets it would be better to understand the format.

<center>
<style>
table.wikitable, table.wikitable th, table.wikitable td, table.wikitable tr {
  border:2px solid rgba(0,0,0,0.8);
}
</style>
<h3>IPv4 Packet Header</h3>
<table class="wikitable" style="margin: 0 auto; text-align: center;border:2px solid rgba(0,0,0,0.8);"><tbody><tr><th><i>Offsets</i></th><th><a href="https://en.wikipedia.org/wiki/Octet_(computing)" title="Octet (computing)">Octet</a></th><th colspan="8">0</th><th colspan="8">1</th><th colspan="8">2</th><th colspan="8">3</th></tr><tr><th><a href="https://en.wikipedia.org/wiki/Octet_(computing)" title="Octet (computing)">Octet</a></th><th><a href="https://en.wikipedia.org/wiki/Bit" title="Bit">Bit</a></th><th style="width:2.6%;">0</th><th style="width:2.6%;">1</th><th style="width:2.6%;">2</th><th style="width:2.6%;">3</th><th style="width:2.6%;">4</th><th style="width:2.6%;">5</th><th style="width:2.6%;">6</th><th style="width:2.6%;">7</th><th style="width:2.6%;">8</th><th style="width:2.6%;">9</th><th style="width:2.6%;">10</th><th style="width:2.6%;">11</th><th style="width:2.6%;">12</th><th style="width:2.6%;">13</th><th style="width:2.6%;">14</th><th style="width:2.6%;">15</th><th style="width:2.6%;">16</th><th style="width:2.6%;">17</th><th style="width:2.6%;">18</th><th style="width:2.6%;">19</th><th style="width:2.6%;">20</th><th style="width:2.6%;">21</th><th style="width:2.6%;">22</th><th style="width:2.6%;">23</th><th style="width:2.6%;">24</th><th style="width:2.6%;">25</th><th style="width:2.6%;">26</th><th style="width:2.6%;">27</th><th style="width:2.6%;">28</th><th style="width:2.6%;">29</th><th style="width:2.6%;">30</th><th style="width:2.6%;">31</th></tr><tr><th>0</th><th>0</th><td colspan="4"><a href="https://en.wikipedia.org/wiki/IPv4#Version">Version</a></td><td colspan="4"><a href="https://en.wikipedia.org/wiki/IPv4#IHL">IHL</a></td><td colspan="6"><a href="https://en.wikipedia.org/wiki/IPv4#DSCP">DSCP</a></td><td colspan="2"><a href="https://en.wikipedia.org/wiki/IPv4#ECN">ECN</a></td><td colspan="16"><a href="https://en.wikipedia.org/wiki/IPv4#Total_Length">Total Length</a></td></tr><tr><th>4</th><th>32</th><td colspan="16"><a href="https://en.wikipedia.org/wiki/IPv4#Identification">Identification</a></td><td colspan="3"><a href="https://en.wikipedia.org/wiki/IPv4#Flags">Flags</a></td><td colspan="13"><a href="https://en.wikipedia.org/wiki/IPv4#Fragment_Offset">Fragment Offset</a></td></tr><tr><th>8</th><th>64</th><td colspan="8"><a href="https://en.wikipedia.org/wiki/IPv4#TTL">Time To Live</a></td><td colspan="8"><a href="https://en.wikipedia.org/wiki/IPv4#Protocol">Protocol</a></td><td colspan="16"><a href="https://en.wikipedia.org/wiki/IPv4#Header_Checksum">Header Checksum</a></td></tr><tr><th>12</th><th>96</th><td colspan="32"><a href="https://en.wikipedia.org/wiki/IPv4#Source_address">Source IP Address</a></td></tr><tr><th>16</th><th>128</th><td colspan="32"><a href="https://en.wikipedia.org/wiki/IPv4#Destination_address">Destination IP Address</a></td></tr><tr><th>20</th><th>160</th><td colspan="32" rowspan="4"><a href="https://en.wikipedia.org/wiki/IPv4#Options">Options</a> (if IHL &gt; 5)</td></tr><tr><th>24</th><th>192</th></tr><tr><th>28</th><th>224</th></tr><tr><th>32</th><th>256</th></tr><tr><th>0</th><th><tt>0</tt></th><td colspan="16">Source port</td><td colspan="16">Destination port</td></tr><tr><th>4</th><th><tt>32</tt></th><td colspan="32">Sequence number</td></tr><tr><th>8</th><th><tt>64</tt></th><td colspan="32">Acknowledgment number (if <tt>ACK</tt> set)</td></tr><tr><th>12</th><th><tt>96</tt></th><td colspan="4">Data offset</td><td colspan="3">Reserved<br><tt><b>0 0 0</b></tt></td><td><tt>N<br>S</tt></td><td><tt>C<br>W<br>R</tt></td><td><tt>E<br>C<br>E</tt></td><td><tt>U<br>R<br>G</tt></td><td><tt>A<br>C<br>K</tt></td><td><tt>P<br>S<br>H</tt></td><td><tt>R<br>S<br>T</tt></td><td><tt>S<br>Y<br>N</tt></td><td><tt>F<br>I<br>N</tt></td><td colspan="16">Window Size</td></tr><tr><th>16</th><th><tt>128</tt></th><td colspan="16">Checksum</td><td colspan="16">Urgent pointer (if <tt>URG</tt> set)</td></tr><tr><th>20<br>...</th><th><tt>160<br>...</tt></th><td colspan="32" style="background:#ffd0d0;">Options (if <i>data offset</i> &gt; 5. Padded at the end with "0" bytes if necessary.)<br>...</td></tr></tbody></table>
</center>


In the code we need the destination IP, source IP, destination port, and source IP.  To find these things we need the size of each byte in the file reader and where each item is in the header.  Currently each byte represents 2 hex numbers (0x00 - 0xFF), which is 8 bits.  This means that the Source IP address is at the 96th octet, which is the 13th byte going to the 17th byte.

A little harder to find is the source port and dest port, this is because you need to go past the IPv4 header and look at the TCP packet.  The first two bytes at the source port and the next two bytes are the destination port.  In this program I don't pad based on the if the options is set, but at the same time options are seldom used and aren't set in nmap.

Once all of the data is gathered from the packet we check to see if the port being accessed is the honeyport and that the source IP isn't the destination IP.  If the port is triggered we use the packet information to replace tokens in the command.  After all of this we push the command to /bin/sh and output the packet information to the console!

A simple process but thanks to working with raw packets it's a little bit of a pain in the ass.  All in all it was a fun project for the night and a great project to protect yourself at the next DefCon you go to!

If you're interested in the source or the build instructions the code is on <a href="https://github.com/0x4445565A/portanoia">Github here</a>.  Let me know <a href="https://twitter.com/0x4445565a">@0x4445565a</a> if you catch any probers!

<img src="/assets/images/action-portanoia.png" alt="Outputting attacker packets to Espeak">
